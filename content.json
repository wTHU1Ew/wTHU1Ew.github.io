{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Thule","url":"https://wTHU1Ew.github.io","root":"/"},"pages":[],"posts":[{"title":"Project-run-006","slug":"Project-run-006","date":"2022-02-21T12:30:44.000Z","updated":"2022-02-21T16:56:52.025Z","comments":true,"path":"2022/02/21/Project-run-006/","link":"","permalink":"https://wthu1ew.github.io/2022/02/21/Project-run-006/","excerpt":"codeql深入学习，cpp学习","text":"codeql深入学习，cpp学习 前言：codeql cpp的snippets终于分析完了（真是懒狗，拖了那么久），以后简历可以改成熟悉codeql而不是了解啦！ codeql深入学习ternaryconditional：代码：12345import cpp from ConditionalExpr ce where ce.getThen().getType() != ce.getElse().getType()select ce 总结：判定 ：？的返回值类型是否一致 todocomment：代码：12345import cpp from Comment c where c.getContents().matches(&quot;%TODO%&quot;)select c 总结：查找指定注释（感觉效率不如ctrl+F…） toomanyparams：代码：12345import cpp from Function f where f.getNumberOfParameters() &gt;= 10 select f 总结：参数太他妈的多啦～ unusedlocalvar：代码：1234567import cpp from LocalScopeVariable lsv, LocalVariable lvwhere //not lsv instanceof Parameter //and not exists(lsv.getAnAccess()) not exists( lv.getAnAccess() )select lv 结果： 总结：寻找未被使用的变量，因为感觉loaclvariable写的简单点就用这个了。 LocalScopeVariable包含所有变量，包括函数参数。 StackScopeVariable不包含static和pthread，static基本是存在data或者bss段，pthread忘了。 LocalVariable不包含函数参数。 unusedmethod：代码：123456789import cpp from MemberFunction mf, FunctionCall fc where mf.getFile().getRelativePath() = &quot;a.cpp&quot; and fc.getTarget() = mf and not mf.isVirtual() and mf.isPrivate() select fc.getLocation().getStartLine() ,fc, mf 结果： 总结：其实思路还是很清晰的，但是自己做了很久，原因是我把使用函数的查询和使用变量的弄混了，都用了类似accesss的查询，但实际上函数得用call查询，而函数的access是查询的类似函数取地址的操作： 1&amp;functionname; unusedparam：代码：123456import cpp from Parameter p where not exists( p.getAnAccess() ) and p.isNamed()select p 总结：主要就那个isNamed要注意一下，但是这种不命名的参数用法我忘了叫啥了 voidreturntype：代码：123456import cpp from MemberFunction mf where mf.hasSpecifier(&quot;const&quot;) and mf.getType() instanceof VoidType select mf 结果： 总结：草，没见过的cpp用法增加了… volatilevariable：代码：12345import cppfrom Variable fwhere f.isVolatile()select f 总结：cpp没见过的用法喜加一 cpp学习：关于类的那些事：","categories":[],"tags":[]},{"title":"Project-run-005","slug":"Project-run-005","date":"2022-02-14T09:16:50.000Z","updated":"2022-02-21T12:27:43.204Z","comments":true,"path":"2022/02/14/Project-run-005/","link":"","permalink":"https://wthu1ew.github.io/2022/02/14/Project-run-005/","excerpt":"codeql深入学习","text":"codeql深入学习 codeql深入学习：mutualrecursion:codeql代码：12345678910import cpp from Function m, Function n where exists( FunctionCall fc | fc.getTarget() = m and fc.getEnclosingFunction() = n ) and exists( FunctionCall fc | fc.getTarget() = n and fc.getEnclosingFunction() = m )select m, m.getLocation().getStartLine().toString(), n, n.getLocation().getStartLine().toString() 结果： 总结：查找互相调用的函数，靠functioncall处的enclosingfunction确定 override-method:代码：12345678910111213import cpp from MemberFunction override, MemberFunction base, File fwhere base.getDeclaringType().getABaseClass*().getName() = &quot;exception&quot; and base.getDeclaringType().getNamespace().toString().matches(&quot;%std%&quot;) and base.getName() = &quot;what&quot; and override.overrides*(base) and override.getFile() = f and f.getRelativePath().toString() = &quot;a.cpp&quot;select override.getDeclaringType(), override 结果： 总结：寻找被复写的成员函数，但是他给的用例我写的demo测试不出来（cpp菜逼是这样的），所以就改了个自己能测试出来的（逃 returnstatement:代码：123456import cpp from ReturnStmt rs where rs.getExpr().(Literal).getValue().toInt() = 0 and rs.getFile().getRelativePath() = &quot;a.cpp&quot;select rs 总结：寻找return 0，自己加了个文件路径指定而已 singletonblock:代码：1234import cpp from BlockStmt bs where bs.getNumStmt() = 1select bs 结果： 总结：注，getNumStmt() &#x3D; 1是针对 123&#123; &#125; 而不是 1&#123;&#125; 所以我推荐这里写getNumStmt()的值为0或1 switchcase:代码：123456import cpp from EnumSwitch es, EnumConstant ec where ec = es.getAMissingCase() and not es.hasDefaultCase() select es, ec 结果： 总结：获得没有default的枚举元素，但是本人很少写枚举+switch，所以个人还没什么理解","categories":[],"tags":[]},{"title":"Project-run-004","slug":"Project-run-004","date":"2022-02-12T18:00:16.000Z","updated":"2022-02-13T21:27:08.479Z","comments":true,"path":"2022/02/13/Project-run-004/","link":"","permalink":"https://wthu1ew.github.io/2022/02/13/Project-run-004/","excerpt":"cpp学习，codeql深入学习，简单算法，背单词","text":"cpp学习，codeql深入学习，简单算法，背单词 前言：今天必定完成全部学习任务，完不成后天不恰饭 cpp学习：map相关:属于map库，std:__1命名空间，建立映射可以使用make_pair codeql深入学习：Field-access:QL代码：1234567import cpp from Field f, FieldAccess fa where f.getName().matches(&quot;aDate&quot;) and f.getDeclaringType().getName() = &quot;Order&quot; and fa.getTarget() = f select fa 结果： 总结：嘛，查询了哪里对指定成员变量进行了操作，个人认为如果更实际一点就还需要补充些修改成员变量的函数调用处，懒得写了 Function-call:QL代码：12345678import cpp from Function f, FunctionCall fc where f.getDeclaringType().getSimpleName().matches(&quot;map&quot;) and f.getDeclaringType().getNamespace().toString().matches(&quot;%std%&quot;) and f.getName().matches(&quot;find&quot;) and fc.getTarget() = f select fc 结果： 总结：注：snnipets里写的function-call个人认为是错的，它对于namespace的处理有问题map属于namspace std::__1, 靠snnipets里的是无法搜索出结果的，所以得加个正则匹配才行 Integer-literal:QL代码：123456import cpp from Literal l where l.getType() instanceof IntType and l.getValue().toInt() = 2 select l.getLocation().getStartLine(), l 结果： 总结：单纯找一下哪里出现了值为2的整数int（我认为） 简单算法：贪心算法：无重叠区域：个人理解：其实一周前看过解析，今天自己做的时候只记得前区间的end要比后区间的begin小，但是忘了sort顺序，比较的是at(0)，导致一开始没做出来。 那么，正确的做法其实是比较at(1)，毕竟越早结束越可能产生更多区间，导致删除的区间更少。 coding:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int eraseOverlapIntervals(vector&lt; vector&lt;int&gt; &gt;&amp; intervals) &#123; int cnt=0; int current_second=0; sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123; return a[1]&lt;b[1]; &#125;); vector&lt; vector&lt;int&gt; &gt;::iterator it=intervals.begin(); current_second=it-&gt;at(1); it++; for(;it!=intervals.end();it++)&#123; if(it-&gt;at(0)&gt;=current_second)&#123; current_second=it-&gt;at(1); &#125;else&#123; cnt++; &#125; &#125; return cnt; &#125;&#125;;int main()&#123; int a[2]=&#123;3, 10&#125;; int b[2]=&#123;0, 5&#125;; int c[2]=&#123;4, 9&#125;; vector&lt;int&gt; aa(a, a+2); vector&lt;int&gt; bb(b, b+2); vector&lt;int&gt; cc(c, c+2); vector&lt; vector&lt;int&gt; &gt; vv; vv.push_back(aa); vv.push_back(bb); vv.push_back(cc); Solution *s=new Solution; cout&lt;&lt;s-&gt;eraseOverlapIntervals(vv); return 0;&#125; 用最少数量飞镖引爆气球: 个人理解：ok，我宣布喜欢让迭代器从end开始操作的人都是大傻逼，这很容易导致越界访问内存～ 言归正传，有点像上一题，不过一开始自己思路错了，想成了考虑最大集合了，应该还是归到集合边界问题。 coding：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int findMinArrowShots(vector&lt; vector&lt;int&gt; &gt;&amp; points) &#123; int start_position = 0; int arrows_num = 0; sort(points.begin(), points.end(), [](vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b)&#123; return a[1] &lt; b[1]; &#125;); vector&lt; vector&lt;int&gt; &gt;::iterator it = points.begin(); start_position = it-&gt;at(1); arrows_num++, it++; for(; it!=points.end(); it++)&#123; if(start_position &gt;= it-&gt;at(0))&#123; continue; &#125;else&#123; arrows_num++; start_position = it-&gt;at(1); &#125; &#125; return arrows_num; &#125;&#125;;int main() &#123; vector&lt;int&gt; a = &#123;1, 2&#125;; vector&lt;int&gt; b = &#123;2, 3&#125;; vector&lt;int&gt; c = &#123;3, 4&#125;; vector&lt;int&gt; d = &#123;4, 5&#125;; vector&lt; vector&lt;int&gt; &gt; v; v.push_back(a); v.push_back(b); v.push_back(c); v.push_back(d); Solution *s = new Solution; cout &lt;&lt; s-&gt;findMinArrowShots(v) &lt;&lt;endl; return 0;&#125; 背单词：复习了30个例句","categories":[],"tags":[{"name":"Project-run","slug":"Project-run","permalink":"https://wthu1ew.github.io/tags/Project-run/"}]},{"title":"Project-run-003","slug":"Project-run-003","date":"2022-02-09T10:55:53.000Z","updated":"2022-02-12T18:03:14.653Z","comments":true,"path":"2022/02/09/Project-run-003/","link":"","permalink":"https://wthu1ew.github.io/2022/02/09/Project-run-003/","excerpt":"修改博客，codeql深入学习","text":"修改博客，codeql深入学习 前言：前两天和Sakura聊了一下，他说codeql不是一个特别完善的工具，最好的用处是不用数据流也能找到的漏洞模式，就好像 1234567a函数里调用b函数对a函数的字段进行初始化但是b函数有一个if判断可以在对指针初始化前就返回造成未初始化的引用Codeql可以很轻松的找到函数a调用函数b，以及函数b里有一个return这种情况 （Sakura原话） So，最近打算看完cpp snippets就OK啦！ 博客修改：照着链接整了一下Google的seo，方便以后搜索到自己以及站内搜索 codeql深入学习:Castexpr:强制类型转换，自己魔改了一下，从非浮点数转化为浮点数（本来好像是浮点数变非浮点数） QL代码：123456789101112131415/** 自己写的不是那么正确的demo qlimport cpp from Cast cwhere c.getType() instanceof FloatingPointType and c.getExpr().getType() instanceof IntTypeselect c*/import cppfrom Cast cwhere c.getType() instanceof FloatingPointType and c.getExpr().getType() instanceof IntegralTypeselect c 结果： 总结：1234getExpr() //获得右式instanceof ... //判定是否为...的子类FloatingPointType //浮点类型，不是float类型指针哈哈哈IntegralType //除了enum和浮点数，都可以是这个子类 Constructor-call:寻找调用构造函数 QL代码：123456import cpp from NewExpr new, Constructor cwhere c = new.getInitializer().(ConstructorCall).getTarget() and c.hasName(&quot;Mynew&quot;) select new 结果： 总结：先通过右式的new加上寻找构造的约束，之后强制类型转换为ConstructorCall（FunctionCall的派生）获取目标，最后通过名字寻找 Derives-from-class：寻找派生类 QL代码：123456import cpp from Class c where c.getABaseClass+().getName().matches(&quot;exception&quot;) and c.getNamespace().getName().matches(&quot;std&quot;) select c 结果： 总结：通过迭代获得最顶层基类的名字且进行约束，由于exception本身就是std命名空间的，所以只要对子类进行命名空间的约束即可 Emptyblock:总结：通过count对getAStmt()进行了计数的一个简单封装，不高兴写demo了 Emptythen:QL代码：12345import cpp from IfStmt is where is.getThen().(BlockStmt).getNumStmt()=0 select is 总结：看一下留个印象就行，不难 困惑： 注释里的4.1.1啥的，到底是指的啥，懵逼 Catch-exception的内容看不懂，就先放着了","categories":[],"tags":[{"name":"Project-run","slug":"Project-run","permalink":"https://wthu1ew.github.io/tags/Project-run/"}]},{"title":"Project_run_002","slug":"Project-run-002","date":"2022-02-05T04:56:04.000Z","updated":"2022-02-12T18:03:22.411Z","comments":true,"path":"2022/02/05/Project-run-002/","link":"","permalink":"https://wthu1ew.github.io/2022/02/05/Project-run-002/","excerpt":"博客修改，cql深入学习，简单算法","text":"博客修改，cql深入学习，简单算法 博客修改：最终还是选择对封面图使用了远程链接，修改了_config.yml后使用标签语法 1&#123;% asset_img img_path ... %&#125; 发现对于封面的cover：，在执行 1hexo g 的时候就会报错了（麻） 简单算法：75. 颜色分类：一开始想用的单指针，分别对0与1处理，总共处理两次，但想想觉得好麻烦，就看到题解里的神解法了，算是动态规划？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt; #include &lt;vector&gt;using namespace std;class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int i=0, len=nums.size(); int zero=0,one=0,two=0; for(;i&lt;len;i++)&#123; if(nums.at(i)==2)&#123; nums.at(two++)=2; &#125; else if(nums.at(i)==1)&#123; nums.at(two++)=2; nums.at(one++)=1; &#125; else if(nums.at(i)==0)&#123; nums.at(two++)=2; nums.at(one++)=1; nums.at(zero++)=0; &#125; /* for(int i=0;i&lt;nums.size();i++)&#123; cout&lt;&lt;nums.at(i)&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl; */ &#125; &#125;&#125;;int main()&#123; int ori[6]=&#123;1,2,0,2,0,1&#125;; vector&lt;int&gt; nums(ori, ori+6); Solution s; s.sortColors(nums); for(int i=0;i&lt;nums.size();i++)&#123; cout&lt;&lt;nums.at(i)&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl; return 0;&#125; 455. 分发饼干：自己随便写了个，然后润到B站再看看贪心算法（原来这玩意不是具体算法，而是局部最佳试图整体最佳的想法2333） 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt; using namespace std; class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; sort(g.begin(), g.end()); sort(s.begin(), s.end()); int cnt=0; for(int i=0;i&lt;s.size();i++)&#123; if(s.at(i)&gt;=g.at(0))&#123; for(;(i+cnt)&lt;s.size()&amp;&amp;cnt&lt;g.size();cnt++)&#123; if(s.at(i+cnt)&lt;g.at(cnt))&#123; break; &#125; &#125; &#125; &#125; return cnt; &#125;&#125;;int main()&#123; Solution S; int a[10]=&#123;1,3,2,5,4,6,7,8,7,9&#125;; int b[5]=&#123;1,0,9,7,4&#125;; vector&lt;int&gt; g(a,a+10); vector&lt;int&gt; s(b,b+5); cout&lt;&lt;S.findContentChildren(g,s)&lt;&lt;endl; return 0;&#125; cql深入学习：今天直接尝试阅读了源码，对于getchild（）存在一些疑惑，明天问完skr再回来补补 源码+注释没好意思问，就自己实践了一下，直接贴源码+自己的注释了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class ArrayExpr extends Expr, @subscriptexpr &#123; override string getAPrimaryQlClass() &#123; result = &quot;ArrayExpr&quot; &#125; /** * 获得被指向的数组或者指针 * This is `arr` in both `arr[0]` and `0[arr]`. */ Expr getArrayBase() &#123; result = this.getChild(0) &#125; /** * 获得数组索引的表达式 * This is `0` in both `arr[0]` and `0[arr]`. */ Expr getArrayOffset() &#123; result = this.getChild(1) &#125; /** * 赋值，自增/减，函数调用则视为被改变 * Holds if this array access is in a position where it is (directly) modified, * for instance by an assignment or an increment/decrement operation. */ predicate isModified() &#123; exists(Assignment a | a.getLValue() = this) or exists(CrementOperation c | c.getOperand() = this) or exists(FunctionCall c | c.getQualifier() = this and c.getTarget().hasName(&quot;operator=&quot;)) &#125; override string toString() &#123; result = &quot;access to array&quot; &#125; /** * 可能被污染？数组本身，偏移被污染，若不确定则也被认为被污染 */ override predicate mayBeImpure() &#123; this.getArrayBase().mayBeImpure() or this.getArrayOffset().mayBeImpure() or this.getArrayBase().getFullyConverted().getType().(DerivedType).getBaseType().isVolatile() or this.getArrayOffset().getFullyConverted().getType().(DerivedType).getBaseType().isVolatile() &#125; /** * 搜索全局污染，不确定也被认为是污染，但它只针对全局变量 * 局部变量再怎么被污染也不被考虑 */ override predicate mayBeGloballyImpure() &#123; this.getArrayBase().mayBeGloballyImpure() or this.getArrayOffset().mayBeGloballyImpure() or this.getArrayBase().getFullyConverted().getType().(DerivedType).getBaseType().isVolatile() or this.getArrayOffset().getFullyConverted().getType().(DerivedType).getBaseType().isVolatile() &#125;&#125;","categories":[],"tags":[{"name":"Project-run","slug":"Project-run","permalink":"https://wthu1ew.github.io/tags/Project-run/"}]},{"title":"Project_run_001","slug":"Project-run-001","date":"2022-02-04T12:03:05.000Z","updated":"2022-02-12T18:03:01.389Z","comments":true,"path":"2022/02/04/Project-run-001/","link":"","permalink":"https://wthu1ew.github.io/2022/02/04/Project-run-001/","excerpt":"今日学习博客搭建，cql深入","text":"今日学习博客搭建，cql深入 博客搭建：主要记录一点自己踩的坑： 使用的nexmoe主题，它的背景是默认磨花的，想不磨花则进入 1/themes/nexmoe/source/css/style.styl 修改blur（）函数的参数为0px 关于图片的链接，可以为远程链接和本地链接（？） 远程链接：点击服务器上的图片，然后复制图片链接即可 本地链接：分为相对路径和绝对路径，我暂时采用的相对路径，设置 1/scaffolds/post.md 添加 1typora-root-url: ../ 使得typora的默认路径修改为和hexo一样的 1/source 而不是 1/source/_post nexmoe中默认带有广告，我选择把_config.nexmoe.yml中最后的sidebar全注释掉了，去你吗的备案号啥的XD 在设置好_config.yml中的themes之后，基本要修改设置就只在 1/_config.nexmoe.yml 中修改就行了，不要弄 1/themes/nexmoe/_config.yml 改了也不会体现在博客上的 cql环节：预计会先把cql自带的demo和曾经的cwe给研究完再研究更深入的，例子都是官网下载的内容中自带的，我就直接用名字，不提供ql代码了，除非自己魔改过 addressof:demo.c:1234567891011121314void test(int* b, int&amp; c);int main()&#123; int a=0; int* b=&amp;a; int&amp; c=a; test(b, c); return 0;&#125;void test(int* b, int&amp; c)&#123; b=&amp;c; return;&#125; 结果:","categories":[],"tags":[{"name":"Project-run","slug":"Project-run","permalink":"https://wthu1ew.github.io/tags/Project-run/"}]},{"title":"杂谈","slug":"杂谈","date":"2022-02-01T18:18:37.627Z","updated":"2022-02-05T21:04:25.670Z","comments":true,"path":"2022/02/02/杂谈/","link":"","permalink":"https://wthu1ew.github.io/2022/02/02/%E6%9D%82%E8%B0%88/","excerpt":"","text":"本人纯懒狗pwn手，博客建设中 个人成分很杂，鉴定为引流蛆","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Project-run","slug":"Project-run","permalink":"https://wthu1ew.github.io/tags/Project-run/"}]}