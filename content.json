{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Thule","url":"https://wTHU1Ew.github.io","root":"/"},"pages":[],"posts":[{"title":"Project-run-004","slug":"Project-run-004","date":"2022-02-12T18:00:16.000Z","updated":"2022-02-12T18:49:35.828Z","comments":true,"path":"2022/02/13/Project-run-004/","link":"","permalink":"https://wthu1ew.github.io/2022/02/13/Project-run-004/","excerpt":"cpp学习，codeql深入学习，简单算法，背单词","text":"cpp学习，codeql深入学习，简单算法，背单词 前言：今天必定完成全部学习任务，完不成后天不恰饭 cpp学习：map相关:codeql深入学习：Field-access:Function-call:注：snnipets里写的function-call个人认为是错的，它对于namespace的处理有问题","categories":[],"tags":[{"name":"Project-run","slug":"Project-run","permalink":"https://wthu1ew.github.io/tags/Project-run/"}]},{"title":"Project-run-003","slug":"Project-run-003","date":"2022-02-09T10:55:53.000Z","updated":"2022-02-12T18:03:14.653Z","comments":true,"path":"2022/02/09/Project-run-003/","link":"","permalink":"https://wthu1ew.github.io/2022/02/09/Project-run-003/","excerpt":"修改博客，codeql深入学习","text":"修改博客，codeql深入学习 前言：前两天和Sakura聊了一下，他说codeql不是一个特别完善的工具，最好的用处是不用数据流也能找到的漏洞模式，就好像 1234567a函数里调用b函数对a函数的字段进行初始化但是b函数有一个if判断可以在对指针初始化前就返回造成未初始化的引用Codeql可以很轻松的找到函数a调用函数b，以及函数b里有一个return这种情况 （Sakura原话） So，最近打算看完cpp snippets就OK啦！ 博客修改：照着链接整了一下Google的seo，方便以后搜索到自己以及站内搜索 codeql深入学习:Castexpr:强制类型转换，自己魔改了一下，从非浮点数转化为浮点数（本来好像是浮点数变非浮点数） QL代码：123456789101112131415/** 自己写的不是那么正确的demo qlimport cpp from Cast cwhere c.getType() instanceof FloatingPointType and c.getExpr().getType() instanceof IntTypeselect c*/import cppfrom Cast cwhere c.getType() instanceof FloatingPointType and c.getExpr().getType() instanceof IntegralTypeselect c 结果： 总结：1234getExpr() //获得右式instanceof ... //判定是否为...的子类FloatingPointType //浮点类型，不是float类型指针哈哈哈IntegralType //除了enum和浮点数，都可以是这个子类 Constructor-call:寻找调用构造函数 QL代码：123456import cpp from NewExpr new, Constructor cwhere c = new.getInitializer().(ConstructorCall).getTarget() and c.hasName(&quot;Mynew&quot;) select new 结果： 总结：先通过右式的new加上寻找构造的约束，之后强制类型转换为ConstructorCall（FunctionCall的派生）获取目标，最后通过名字寻找 Derives-from-class：寻找派生类 QL代码：123456import cpp from Class c where c.getABaseClass+().getName().matches(&quot;exception&quot;) and c.getNamespace().getName().matches(&quot;std&quot;) select c 结果： 总结：通过迭代获得最顶层基类的名字且进行约束，由于exception本身就是std命名空间的，所以只要对子类进行命名空间的约束即可 Emptyblock:总结：通过count对getAStmt()进行了计数的一个简单封装，不高兴写demo了 Emptythen:QL代码：12345import cpp from IfStmt is where is.getThen().(BlockStmt).getNumStmt()=0 select is 总结：看一下留个印象就行，不难 困惑： 注释里的4.1.1啥的，到底是指的啥，懵逼 Catch-exception的内容看不懂，就先放着了","categories":[],"tags":[{"name":"Project-run","slug":"Project-run","permalink":"https://wthu1ew.github.io/tags/Project-run/"}]},{"title":"Project_run_002","slug":"Project-run-002","date":"2022-02-05T04:56:04.000Z","updated":"2022-02-12T18:03:22.411Z","comments":true,"path":"2022/02/05/Project-run-002/","link":"","permalink":"https://wthu1ew.github.io/2022/02/05/Project-run-002/","excerpt":"博客修改，cql深入学习，简单算法","text":"博客修改，cql深入学习，简单算法 博客修改：最终还是选择对封面图使用了远程链接，修改了_config.yml后使用标签语法 1&#123;% asset_img img_path ... %&#125; 发现对于封面的cover：，在执行 1hexo g 的时候就会报错了（麻） 简单算法：75. 颜色分类：一开始想用的单指针，分别对0与1处理，总共处理两次，但想想觉得好麻烦，就看到题解里的神解法了，算是动态规划？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt; #include &lt;vector&gt;using namespace std;class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int i=0, len=nums.size(); int zero=0,one=0,two=0; for(;i&lt;len;i++)&#123; if(nums.at(i)==2)&#123; nums.at(two++)=2; &#125; else if(nums.at(i)==1)&#123; nums.at(two++)=2; nums.at(one++)=1; &#125; else if(nums.at(i)==0)&#123; nums.at(two++)=2; nums.at(one++)=1; nums.at(zero++)=0; &#125; /* for(int i=0;i&lt;nums.size();i++)&#123; cout&lt;&lt;nums.at(i)&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl; */ &#125; &#125;&#125;;int main()&#123; int ori[6]=&#123;1,2,0,2,0,1&#125;; vector&lt;int&gt; nums(ori, ori+6); Solution s; s.sortColors(nums); for(int i=0;i&lt;nums.size();i++)&#123; cout&lt;&lt;nums.at(i)&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl; return 0;&#125; 455. 分发饼干：自己随便写了个，然后润到B站再看看贪心算法（原来这玩意不是具体算法，而是局部最佳试图整体最佳的想法2333） 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt; using namespace std; class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; sort(g.begin(), g.end()); sort(s.begin(), s.end()); int cnt=0; for(int i=0;i&lt;s.size();i++)&#123; if(s.at(i)&gt;=g.at(0))&#123; for(;(i+cnt)&lt;s.size()&amp;&amp;cnt&lt;g.size();cnt++)&#123; if(s.at(i+cnt)&lt;g.at(cnt))&#123; break; &#125; &#125; &#125; &#125; return cnt; &#125;&#125;;int main()&#123; Solution S; int a[10]=&#123;1,3,2,5,4,6,7,8,7,9&#125;; int b[5]=&#123;1,0,9,7,4&#125;; vector&lt;int&gt; g(a,a+10); vector&lt;int&gt; s(b,b+5); cout&lt;&lt;S.findContentChildren(g,s)&lt;&lt;endl; return 0;&#125; cql深入学习：今天直接尝试阅读了源码，对于getchild（）存在一些疑惑，明天问完skr再回来补补 源码+注释没好意思问，就自己实践了一下，直接贴源码+自己的注释了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class ArrayExpr extends Expr, @subscriptexpr &#123; override string getAPrimaryQlClass() &#123; result = &quot;ArrayExpr&quot; &#125; /** * 获得被指向的数组或者指针 * This is `arr` in both `arr[0]` and `0[arr]`. */ Expr getArrayBase() &#123; result = this.getChild(0) &#125; /** * 获得数组索引的表达式 * This is `0` in both `arr[0]` and `0[arr]`. */ Expr getArrayOffset() &#123; result = this.getChild(1) &#125; /** * 赋值，自增/减，函数调用则视为被改变 * Holds if this array access is in a position where it is (directly) modified, * for instance by an assignment or an increment/decrement operation. */ predicate isModified() &#123; exists(Assignment a | a.getLValue() = this) or exists(CrementOperation c | c.getOperand() = this) or exists(FunctionCall c | c.getQualifier() = this and c.getTarget().hasName(&quot;operator=&quot;)) &#125; override string toString() &#123; result = &quot;access to array&quot; &#125; /** * 可能被污染？数组本身，偏移被污染，若不确定则也被认为被污染 */ override predicate mayBeImpure() &#123; this.getArrayBase().mayBeImpure() or this.getArrayOffset().mayBeImpure() or this.getArrayBase().getFullyConverted().getType().(DerivedType).getBaseType().isVolatile() or this.getArrayOffset().getFullyConverted().getType().(DerivedType).getBaseType().isVolatile() &#125; /** * 搜索全局污染，不确定也被认为是污染，但它只针对全局变量 * 局部变量再怎么被污染也不被考虑 */ override predicate mayBeGloballyImpure() &#123; this.getArrayBase().mayBeGloballyImpure() or this.getArrayOffset().mayBeGloballyImpure() or this.getArrayBase().getFullyConverted().getType().(DerivedType).getBaseType().isVolatile() or this.getArrayOffset().getFullyConverted().getType().(DerivedType).getBaseType().isVolatile() &#125;&#125;","categories":[],"tags":[{"name":"Project-run","slug":"Project-run","permalink":"https://wthu1ew.github.io/tags/Project-run/"}]},{"title":"Project_run_001","slug":"Project-run-001","date":"2022-02-04T12:03:05.000Z","updated":"2022-02-12T18:03:01.389Z","comments":true,"path":"2022/02/04/Project-run-001/","link":"","permalink":"https://wthu1ew.github.io/2022/02/04/Project-run-001/","excerpt":"今日学习博客搭建，cql深入","text":"今日学习博客搭建，cql深入 博客搭建：主要记录一点自己踩的坑： 使用的nexmoe主题，它的背景是默认磨花的，想不磨花则进入 1/themes/nexmoe/source/css/style.styl 修改blur（）函数的参数为0px 关于图片的链接，可以为远程链接和本地链接（？） 远程链接：点击服务器上的图片，然后复制图片链接即可 本地链接：分为相对路径和绝对路径，我暂时采用的相对路径，设置 1/scaffolds/post.md 添加 1typora-root-url: ../ 使得typora的默认路径修改为和hexo一样的 1/source 而不是 1/source/_post nexmoe中默认带有广告，我选择把_config.nexmoe.yml中最后的sidebar全注释掉了，去你吗的备案号啥的XD 在设置好_config.yml中的themes之后，基本要修改设置就只在 1/_config.nexmoe.yml 中修改就行了，不要弄 1/themes/nexmoe/_config.yml 改了也不会体现在博客上的 cql环节：预计会先把cql自带的demo和曾经的cwe给研究完再研究更深入的，例子都是官网下载的内容中自带的，我就直接用名字，不提供ql代码了，除非自己魔改过 addressof:demo.c:1234567891011121314void test(int* b, int&amp; c);int main()&#123; int a=0; int* b=&amp;a; int&amp; c=a; test(b, c); return 0;&#125;void test(int* b, int&amp; c)&#123; b=&amp;c; return;&#125; 结果:","categories":[],"tags":[{"name":"Project-run","slug":"Project-run","permalink":"https://wthu1ew.github.io/tags/Project-run/"}]},{"title":"杂谈","slug":"杂谈","date":"2022-02-01T18:18:37.627Z","updated":"2022-02-05T21:04:25.670Z","comments":true,"path":"2022/02/02/杂谈/","link":"","permalink":"https://wthu1ew.github.io/2022/02/02/%E6%9D%82%E8%B0%88/","excerpt":"","text":"本人纯懒狗pwn手，博客建设中 个人成分很杂，鉴定为引流蛆","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Project-run","slug":"Project-run","permalink":"https://wthu1ew.github.io/tags/Project-run/"}]}