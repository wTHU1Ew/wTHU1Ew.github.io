{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Thule","url":"https://wTHU1Ew.github.io","root":"/"},"pages":[],"posts":[{"title":"Projec-run-014","slug":"Project-run-014","date":"2022-03-15T03:54:34.000Z","updated":"2022-03-15T19:41:11.690Z","comments":true,"path":"2022/03/15/Project-run-014/","link":"","permalink":"https://wthu1ew.github.io/2022/03/15/Project-run-014/","excerpt":"","text":"前言：昨天确定了自己要考托福的想法，然后就突然心理崩溃了，ccp我草泥马 整理博客：把上周的博客都整理发布了一下，顺带把以前博客的封面也换上了 pwn college：107:见120(待修改) 108:呃呃，stdin好像也是能传文件描述符的，以前记录的报错似乎来自interactive（） 12345from pwn import *from subprocess import *sh = process([&quot;/challenge/embryoio_level108&quot;], stderr=open(&quot;108t.txt&quot;, &quot;r&quot;), stdin=2)#sleep(100)sh.interactive() 109:like 108 110:1kill -s 111:like 110 112:写个c的启动一下就行了，这里我踩两个坑（我怎么这么菜），string做execve的参数出大问题了 and char * []忘记加NULL了 113:依旧是计算，试了一下把生成的文件用python启动也是可以过检测的，再碰到很麻烦的计算可能要写个python自动处理一下 114:1ln -s 115:化身腻鬼！懒得敲命令行了，全部写成c了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;unistd.h&gt;#include &lt;cstring&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;iostream&gt;#include &lt;fcntl.h&gt;using namespace std;int pwncollege();int main() &#123; pid_t p1, p2, p3; char * cmd1[]=&#123;&quot;export PATH=$PATH:/home/hacker&quot;, NULL&#125;; if ((p2=fork())==0) &#123; execve(cmd1[0], NULL, NULL); return 0; &#125; int i1; waitpid(p1, &amp;i1, 0); char * cmd2[]=&#123;&quot;ln -s /challenge/embryoio_level115 hdymqj&quot;, NULL&#125;; if ((p2=fork())==0) &#123; execve(cmd2[0], NULL, NULL); return 0; &#125; int i2; waitpid(p1, &amp;i2, 0); char * cmd[]=&#123;&quot;/challenge/embryoio_level115&quot;, NULL&#125;; char * arg[]=&#123;&quot;hdymqj&quot;, NULL&#125;; if ((p3=fork())==0) &#123; execve(cmd[0], arg, NULL); return 0; &#125; int i; waitpid(p3, &amp;i, 0); return 0;&#125;int pwncollege() &#123; return 0;&#125; 116:重定向无法直接在execve的cmd中使用，还是得靠dup2来重定向 12345678910111213141516171819202122232425262728293031323334353637#include &lt;unistd.h&gt;#include &lt;cstring&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;iostream&gt;#include &lt;fcntl.h&gt;using namespace std;int pwncollege();int main() &#123; pid_t p1, p2, p3; char * cmd[]=&#123;&quot;/challenge/embryoio_level116&quot;, NULL&#125;; if ((p3=fork())==0) &#123; int fin_in = open(&quot;./p1&quot;, O_RDONLY); if(fin_in&lt;0) &#123; perror(&quot;open error\\n&quot;); &#125; else &#123; dup2(fin_in, STDIN_FILENO); execve(cmd[0], NULL, NULL); cout &lt;&lt; &quot;execve success!\\n&quot;; &#125; return 0; &#125; int i; waitpid(p3, &amp;i, 0); return 0;&#125;int pwncollege() &#123; return 0;&#125; 117:like 116 118:没啥好说的 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;unistd.h&gt;#include &lt;cstring&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;iostream&gt;#include &lt;fcntl.h&gt;using namespace std;int pwncollege();int main() &#123; pid_t p1, p2, p3; char * cmd[]=&#123;&quot;/challenge/embryoio_level118&quot;, NULL&#125;; if ((p3=fork())==0) &#123; int fin_in = open(&quot;./p1&quot;, O_RDWR); if(fin_in&lt;0) &#123; perror(&quot;open in error\\n&quot;); &#125; int fin_out = open(&quot;./p2&quot;, O_RDWR); if(fin_out&lt;0) &#123; perror(&quot;open in error\\n&quot;); &#125; else &#123; dup2(fin_in, STDIN_FILENO); dup2(fin_out, STDOUT_FILENO); execve(cmd[0], NULL, NULL); cout &lt;&lt; &quot;execve success!\\n&quot;; &#125; return 0; &#125; int i; waitpid(p3, &amp;i, 0); return 0;&#125;int pwncollege() &#123; return 0;&#125; 119:和118一模一样 120:从布医师傅那偷来的代码改了一些，注意不用大文件读密码会报错，以及要计算1，2以及密码文件对数量的影响 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;unistd.h&gt;#include &lt;cstring&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;iostream&gt;#include &lt;fcntl.h&gt;using namespace std;int pwncollege();int main()&#123; int fd; string file=&quot;./file/&quot;; char * cmd[]= &#123;&quot;/challenge/embryoio_level120&quot;, NULL&#125;; for(int i=0; i&lt;339; i++)&#123; string filex = file + to_string(i); const char* filename = filex.c_str(); open(filename, O_RDWR); &#125; int pid; int f = open(&quot;./120t.txt&quot;, O_RDWR); if(f&lt;0) &#123; cout &lt;&lt; &quot;open error\\n&quot;; &#125; if((pid=fork())==0) &#123; dup2(f, STDIN_FILENO); execve(cmd[0], cmd, NULL); cout &lt;&lt; &quot;execve success\\n&quot;; return 0; &#125; int i; waitpid(pid, &amp;i, 0); return 0;&#125;int pwncollege() &#123; return 0;&#125; python自动生成： 1234file = &quot;./file/&quot; for i in range(314): open(file+str(i), mode=&#x27;w&#x27;)","categories":[],"tags":[]},{"title":"Project-run-013","slug":"Project-run-013","date":"2022-03-12T12:41:33.000Z","updated":"2022-03-15T04:25:04.693Z","comments":true,"path":"2022/03/12/Project-run-013/","link":"","permalink":"https://wthu1ew.github.io/2022/03/12/Project-run-013/","excerpt":"pwn college 第二章","text":"pwn college 第二章 91. bash脚本里设置命名管道，之后重定向92. 利用基础的连续输入输出重定向1command &lt; file1 &gt; file2 只不过是把file变为命名管道 93. 先利用92的命令，执行，再在第二个终端执行 cat &lt; p2， 最后在第三个终端执行cat &gt; p1，同时输入随机数值就行了94. waiting…95. 意义不明96. 意义不明97.12先用kill -l查找再用kill -s发送 98. 一个一个分次发送…99. 呃呃100. 我不好说101. 记得先链接 123from pwn import *sh = process([&quot;/tmp/eblytq&quot;, &quot;/challenge/embryoio_level101&quot;)sh.interactive() 102. 昨天设置PATH的方法太暴力了，今天更新了一下，设置为增加而不是重制 1export PATH=$PATH:/home/hacker &#123;% asset_img ha.jpeg %&#125; 103. 创建一个FIFO，之后在shell1先运行着 1cat &gt; p1 之后跑这脚本就行了，我w和r老分不清（哭） 12345from pwn import *f = open(&quot;p1&quot;, &quot;r&quot;)sh = process([&quot;/challenge/embryoio_level103&quot;], stdin = f)sh.interactive() 104. 类似103105. 痛苦的r和w 1234from pwn import *f = open(&quot;./p2&quot;, &quot;w&quot;)sh = process([&quot;/challenge/embryoio_level105&quot;], stdin=open(&quot;./p1&quot;, &quot;r&quot;), stdout=f.fileno())sleep(5) ​ 一天不色色，浑身难受受，再见，俺上床色色去了","categories":[],"tags":[]},{"title":"Project-run-012","slug":"Project-run-012","date":"2022-03-11T07:40:26.000Z","updated":"2022-03-15T04:23:28.752Z","comments":true,"path":"2022/03/11/Project-run-012/","link":"","permalink":"https://wthu1ew.github.io/2022/03/11/Project-run-012/","excerpt":"pwn college 第二章","text":"pwn college 第二章 76. python的只用一个环境变量启动​```python from pwn import * start=[&quot;env&quot;,&quot;-i&quot;, &quot;138=yywwblelug&quot;, &quot;/challenge/embryoio_level76&quot;] sh = process(start) sh.interactive() ​``` 77. 多参数+单环境变量​```python from pwn import * start=[&quot;env&quot;, &quot;-i&quot;, &quot;73=ginplctvuq&quot;, &quot;/challenge/embryoio_level77&quot;] for i in range(90): start.append(&quot;ckfiyfirjd&quot;) sh = process(start) sh.interactive() ​``` 78. 不是用管道，而是输入重定向，并且要用指定工作目录​```python from pwn import * p=open(&quot;ifozkt&quot;, &quot;w&quot;) sh=process(&quot;/challenge/embryoio_level78&quot;, stdin=p.fileno()) print(sh.recv()) print(sh.recv()) p.close() ​``` 79. argv里用cd不行，cd并不是bin目录中的玩意，而是系统自带的cwd是设置workspace，executable是指定argv[0]的可执行文件所在目录（而不是命令行的意思） ​```python from pwn import * p=open(&quot;ifozkt&quot;, &quot;w&quot;) sh=process([&quot;/challenge/embryoio_level79&quot;], stdin=p.fileno(),cwd=&quot;/tmp/doektz&quot;) sh.interactive() ​``` 80. cpp多参数启动程序​```c++ #include &lt;unistd.h&gt; #include &lt;cstring&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;iostream&gt; #define NUM 300 using namespace std; int pwncollege(); int main() &#123; pid_t fd; char * cmd[] = &#123;&quot;/challenge/embryoio_level80&quot;, NULL&#125;; char * argv[NUM] = &#123;&quot;/challenge/embryoio_level80&quot;, NULL&#125;; char * envp[] = &#123;NULL&#125;; for(int i = 1; i &lt; NUM -1; i++) &#123; argv[i] = &quot;bzudqxryyw&quot;; &#125; argv[NUM - 1] = NULL; if((fd=fork())==0)&#123; execve(cmd[0], argv, envp); &#125; int s1; waitpid(fd, &amp;s1, 0); return 0; &#125; int pwncollege() &#123; return 0; &#125; ​``` 81. cpp无参数启动，就是argv设置为NULL咯～​```c++ #include &lt;unistd.h&gt; #include &lt;cstring&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;iostream&gt; #define NUM 300 using namespace std; int pwncollege(); int main() &#123; pid_t fd; char * cmd[] = &#123;&quot;/challenge/embryoio_level81&quot;, NULL&#125;; char * argv[NUM] = &#123;&quot;/challenge/embryoio_level81&quot;, NULL&#125;; char * envp[] = &#123;NULL&#125;; for(int i = 1; i &lt; NUM -1; i++) &#123; argv[i] = &quot;bzudqxryyw&quot;; &#125; argv[NUM - 1] = NULL; if((fd=fork())==0)&#123; execve(cmd[0], NULL, envp); &#125; int s1; waitpid(fd, &amp;s1, 0); return 0; &#125; int pwncollege() &#123; return 0; &#125; ​``` 82. cpp带环境变量启动，设置envp就行了​```c++ #include &lt;unistd.h&gt; #include &lt;cstring&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;iostream&gt; #define NUM 300 using namespace std; int pwncollege(); int main() &#123; pid_t fd; char * cmd[] = &#123;&quot;/challenge/embryoio_level82&quot;, NULL&#125;; char * argv[NUM] = &#123;&quot;/challenge/embryoio_level82&quot;, NULL&#125;; char * envp[] = &#123;&quot;248=idctlhchch&quot;&#125;; for(int i = 1; i &lt; NUM -1; i++) &#123; argv[i] = &quot;bzudqxryyw&quot;; &#125; argv[NUM - 1] = NULL; if((fd=fork())==0)&#123; execve(cmd[0], NULL, envp); &#125; int s1; waitpid(fd, &amp;s1, 0); return 0; &#125; int pwncollege() &#123; return 0; &#125; ​``` 83. nothing was happened in Tiananmen Square~84. cpp重定向见31，记得随机文件要在那个随机文件夹下面​```c++ #include &lt;unistd.h&gt; #include &lt;cstring&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;iostream&gt; #define NUM 300 using namespace std; int pwncollege(); int main() &#123; pid_t fd; char * cmd[] = &#123;&quot;/challenge/embryoio_level84&quot;, NULL&#125;; char * argv[NUM] = &#123;&quot;/challenge/embryoio_level84&quot;, NULL&#125;; char * envp[] = &#123;&quot;318=ncoszaklgf&quot;&#125;; for(int i = 1; i &lt; NUM -1; i++) &#123; argv[i] = &quot;qnolkcgwbm&quot;; &#125; argv[NUM - 1] = NULL; if((fd=fork())==0)&#123; chdir(&quot;/tmp/ymtphu&quot;); freopen(&quot;./zehqpr&quot;, &quot;r&quot;, stdin); execve(cmd[0], argv, envp); &#125; int s1; waitpid(fd, &amp;s1, 0); return 0; &#125; int pwncollege() &#123; return 0; &#125; ​``` 85. 不如84难度 算数？ 我是按计算器的…因为他没设置时间限制 88.🇺🇦 1ln -s /challenge/... /tmp...然后在bash脚本里运行别名 改变PATH 1export PATH=./:PATH 学会mkfifo后开俩终端就行了 anki背了150张卡片，背麻了","categories":[],"tags":[{"name":"pwn college","slug":"pwn-college","permalink":"https://wthu1ew.github.io/tags/pwn-college/"}]},{"title":"Project-run-011","slug":"Project-run-011","date":"2022-03-09T04:58:41.000Z","updated":"2022-03-15T21:03:05.151Z","comments":true,"path":"2022/03/09/Project-run-011/","link":"","permalink":"https://wthu1ew.github.io/2022/03/09/Project-run-011/","excerpt":"pwn college 第二章","text":"pwn college 第二章 30. 同2931. execve加参​```c++ #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include &lt;unistd.h&gt; #include&lt;sys/wait.h&gt; using namespace std; int pwncollege() &#123; return 0; &#125; int main() &#123; int pid = fork(); if (pid == 0) &#123; int test; char * argv[] = &#123;&quot;/challenge/embryoio_level31&quot;, &quot;rktlxqdhwt&quot;, NULL&#125;; if(execve(&quot;/challenge/embryoio_level31&quot;, argv, NULL) == -1) &#123; cout &lt;&lt; &quot;execl error&quot;; exit(-1); &#125; &#125; wait(NULL); return 0; &#125; ​``` 32. char * name[]记得加NULL，execve第三个参数为envp​```c++ #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include &lt;unistd.h&gt; #include&lt;sys/wait.h&gt; using namespace std; int pwncollege() &#123; return 0; &#125; int main() &#123; int pid = fork(); if (pid == 0) &#123; int test; char * env[]=&#123;&quot;jweldt=flyvvnptgn&quot;, NULL&#125;; char * argv[] = &#123;&quot;/challenge/embryoio_level32&quot;, NULL&#125;; if(execve(&quot;/challenge/embryoio_level32&quot;, argv, env) == -1) &#123; cout &lt;&lt; &quot;execve error\\n&quot;; exit(-1); &#125; &#125; wait(NULL); return 0; &#125; ​``` 33. 方法1​```c++ #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;unistd.h&gt; #include&lt;sys/wait.h&gt; #include&lt;sys/types.h&gt; #include&lt;sys/stat.h&gt; #include&lt;fcntl.h&gt; using namespace std; int pwncollege() &#123; return 0; &#125; int main() &#123; int pid = fork(); if (pid == 0) &#123; int test; char * argv[] = &#123;&quot;/challenge/embryoio_level33&quot;, NULL&#125;; int fin = open(&quot;/tmp/cqccay&quot;, O_RDWR); if(fin &lt; 0) &#123; cout &lt;&lt; &quot;open error\\n&quot;; &#125; dup2(fin, STDIN_FILENO); close(fin); if(execve(&quot;/challenge/embryoio_level33&quot;, argv, NULL) == -1) &#123; cout &lt;&lt; &quot;execve error\\n&quot;; exit(-1); &#125; &#125; wait(NULL); return 0; &#125; ​``` 方法2 ​```c++ #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;unistd.h&gt; #include&lt;sys/wait.h&gt; #include&lt;sys/types.h&gt; #include&lt;sys/stat.h&gt; #include&lt;fcntl.h&gt; using namespace std; int pwncollege() &#123; return 0; &#125; int main() &#123; int pid = fork(); if (pid == 0) &#123; int test; char * argv[] = &#123;&quot;/challenge/embryoio_level33&quot;, NULL&#125;; freopen(&quot;/tmp/cqccay&quot;, &quot;r&quot;, stdin); if(execve(&quot;/challenge/embryoio_level33&quot;, argv, NULL) == -1) &#123; cout &lt;&lt; &quot;execve error\\n&quot;; exit(-1); &#125; &#125; wait(NULL); return 0; &#125; ​``` 34. 参考33的方法2​```c++ #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;unistd.h&gt; #include&lt;sys/wait.h&gt; #include&lt;sys/types.h&gt; #include&lt;sys/stat.h&gt; #include&lt;fcntl.h&gt; using namespace std; int pwncollege() &#123; return 0; &#125; int main() &#123; int pid = fork(); if (pid == 0) &#123; int test; char * argv[] = &#123;&quot;/challenge/embryoio_level34&quot;, NULL&#125;; freopen(&quot;/tmp/exscge&quot;, &quot;w&quot;, stdout); if(execve(&quot;/challenge/embryoio_level34&quot;, argv, NULL) == -1) &#123; cout &lt;&lt; &quot;execve error\\n&quot;; exit(-1); &#125; &#125; wait(NULL); return 0; &#125; ​``` 35. 抽象，execve的envp不设置就是不带环境变量哈哈哈36.1/challenge/embryoio_level36 | cat 37.1/challenge/embryoio_level37 | grep pwn 38.1/challenge/embryoio_level38 | sed -n p 39. 连续俩管道符+rev40. 把cat放管道符左边41. 大文件，指写了十万行密码（42. bash+管道43. 同4244. 同4245. 同4246. 同4247. 同4248. https://blog.csdn.net/qq_34355232/article/details/8770941849. 同4850. 同4851. 同4852. 注意，如果使用print，则导致无法输入，所以得大文件 or 不用print53. 同4854. 同4855. 同4856. 同4857. 同4858. 同4859. 同4860. 被拷打的快哭了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;unistd.h&gt;#include &lt;cstring&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;iostream&gt;using namespace std;int pwncollege();int main() &#123; int fd[2]; if(pipe(fd) == -1) &#123; perror(&quot;pipe error\\n&quot;); &#125; cout &lt;&lt; &quot;parent pid: &quot; &lt;&lt; getpid() &lt;&lt; endl; pid_t pid1, pid2; pid1 = fork(); if( pid1 == 0) &#123; cout &lt;&lt; &quot;child1 pid: &quot; &lt;&lt; getpid() &lt;&lt; endl; close(fd[0]); dup2(fd[1], STDOUT_FILENO); if(execlp(&quot;/challenge/embryoio_level60&quot;, &quot;/challenge/embryoio_level60&quot;, NULL) == -1) &#123; perror(&quot;level60 error\\n&quot;); &#125; return 0; &#125; pid2 = fork(); if( pid2 == 0) &#123; cout &lt;&lt; &quot;child2 pid: &quot; &lt;&lt; getpid() &lt;&lt; endl; close(fd[1]); dup2(fd[0], STDIN_FILENO); if(execlp(&quot;cat&quot;, &quot;cat&quot;, NULL) == -1) &#123; perror(&quot;cat error\\n&quot;); &#125; return 0; &#125; int s1, s2; pid_t pp1, pp2; pp1 = waitpid(pid1, &amp;s1, 0); pp2 = waitpid(pid2, &amp;s2, 0); close(fd[0]); close(fd[1]); dup2(1, STDOUT_FILENO); cout &lt;&lt; &quot;pp1: &quot; &lt;&lt; pp1 &lt;&lt; endl; cout &lt;&lt; &quot;pp2: &quot; &lt;&lt; pp2 &lt;&lt; endl; return 0;&#125;int pwncollege() &#123; return 0;&#125; 参考1 参考2 61. 同6062. 同6063. 同60，但是我仍然未掌握cpp连续两次匿名管道的用法64. 同6065. 同6366. 参考 1find /challenge/ -name embryoio_* -exec &#123;&#125; \\; 67. 我去，参数是加在{}与\\ 之间 1find /challenge/ -name em* -exec &#123;&#125; cixmygqnxu \\; 68. 我复制了很多参数，等学完shell我重新来写69. execlp的第二个参数设置为NULL就行了，二进制程序居然有默认参数，我惊了，而且python是行不通的，提示docker啥的，阿巴阿巴 123456789101112131415161718192021#include &lt;unistd.h&gt;#include &lt;cstring&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;iostream&gt;using namespace std;int pwncollege();int main() &#123; char * cmd[] = &#123;&quot;/challenge/embryoio_level69&quot;, NULL&#125;; execlp(cmd[0], NULL, NULL); return 0;&#125;int pwncollege() &#123; return 0;&#125; 70. 参考 1234567891011121314151617181920212223242526#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;iostream&gt;using namespace std;int pwncollege();int main() &#123; char * cmd[] = &#123;&quot;/challenge/embryoio_level70&quot;, NULL&#125;; char * argv[180] = &#123;&quot;/challenge/embryoio_level70&quot;, NULL&#125;; char * env[] = &#123;&quot;144=mexlijdgfo&quot;, NULL&#125;; for(int i = 1; i&lt; 179;i++) &#123; argv[i]=&quot;mexlijdgfo&quot;; &#125; argv[179] = NULL; //cout &lt;&lt; argv[0] &lt;&lt; argv[1] &lt;&lt; endl; execve(cmd[0], argv, env); return 0;&#125;int pwncollege() &#123; return 0;&#125; 71. 同7072. 改变文件位置73. 草，折磨了好久 12345678910111213141516171819202122#include &lt;unistd.h&gt;#include &lt;cstring&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;iostream&gt;using namespace std;int pwncollege();int main() &#123; chdir(&quot;/tmp/cytlpa/&quot;); char * cmd[] = &#123;&quot;/challenge/embryoio_level73&quot;, NULL&#125;; execlp(cmd[0], cmd[0], NULL); return 0;&#125;int pwncollege() &#123; return 0;&#125; 74. 列表+append 123456from pwn import *start=[&quot;/challenge/embryoio_level74&quot;]for i in range(150): start.append(&quot;qgroocqxhn&quot;)sh = process(start)sh.interactive() 75. 类似69，但改为用python包一层process(“75”)","categories":[],"tags":[{"name":"pwn college","slug":"pwn-college","permalink":"https://wthu1ew.github.io/tags/pwn-college/"}]},{"title":"Project-run-010","slug":"Project-run-010","date":"2022-03-08T02:37:20.000Z","updated":"2022-03-15T21:02:43.518Z","comments":true,"path":"2022/03/08/Project-run-010/","link":"","permalink":"https://wthu1ew.github.io/2022/03/08/Project-run-010/","excerpt":"pwn college第二章","text":"pwn college第二章 1. 直接打开2. 根据info输入值3. 设置arg4. info提到了environment variable所以export设置5. 输入重定向6. 输出重定向7. 不能一个一个unset，不仅傻逼还总是剩一个，加上env -i就行了8. 在home文件夹写bash脚本，用bash运行9. 同8，然后手动输入10. 同9，加参数11. 同912. 同9，bash脚本加入重定向 &lt; tmp下那个文件13. 同9，bash脚本加入重定向 &gt; 到tmp下那个文件14. 同9，加前缀15. 切换到ipython，在shell命令前加上!就行了16. 同1517. 同1518. 同15，但是切换到ipython后!export设置环境变量没法设置成功，所以采用!env设置了临时环境变量19. 原 来 可 以 用 pwntools，so 以后直接干exp咯20. pwntools的输出重定向，加了一下布医师傅聊了一下stdout用法，做出来了​```python from pwn import * sh=process([&quot;/challenge/embryoio_level20&quot;], stdout=open(&quot;/tmp/axijfy&quot;, &quot;w&quot;)) ​``` 21. 利用args即可​```python from pwn import * sh=process([&quot;env&quot;, &quot;-i&quot;, &quot;/challenge/embryoio_level21&quot;]) sh.recv() sh.interactive() ​``` 22. python跑py23. 同2224. 同2225. 同22，试了一下列表里加export还是不行，可能得找路径，但是我选择env26. 删去交互，两次print(recv())可以避免报错（在我这是这样的）27. 同20，但是存在一些bug，依旧是interactive导致，不报错无法写入，报错后删去interactive却依旧可以写入，抽象28. 同2129. wait(NULL)很关键，让子进程先运行结束，否则则是父进程先，而导致检测失败​```c++ #include&lt;iostream&gt; #include&lt;cstdlib&gt; #include &lt;unistd.h&gt; #include&lt;sys/wait.h&gt; using namespace std; int pwncollege() &#123; return 0; &#125; int main() &#123; int pid = fork(); if(pid == -1) &#123; cout &lt;&lt; &quot;fork error&quot;; &#125; else if (pid == 0) &#123; int test; if(execl(&quot;/challenge/embryoio_level29&quot;, NULL) == -1) &#123; cout &lt;&lt; &quot;execl error&quot;; exit(-1); &#125; &#125; else &#123; wait(NULL); cout&lt;&lt;&quot;crazy&quot;; exit(0); &#125; return 0; &#125; ​```","categories":[],"tags":[{"name":"pwn college","slug":"pwn-college","permalink":"https://wthu1ew.github.io/tags/pwn-college/"}]},{"title":"Project-run-009","slug":"Project-run-009","date":"2022-03-02T06:34:32.000Z","updated":"2022-03-15T21:02:08.428Z","comments":true,"path":"2022/03/02/Project-run-009/","link":"","permalink":"https://wthu1ew.github.io/2022/03/02/Project-run-009/","excerpt":"","text":"前言：前几天疯狂沉迷赛马娘和老头环，可算是打腻了，开始学习！ cpp学习： 以后function point parameters尽量用const修饰一下吧 auto类型只能单值初始化，而不能用来初始化列表 sad，函数指针好绕，两个解决方法 1234567//1.auto ptr = &amp;func;//但是要注意自己提供的初值类型是否正确//2.typedef double * (*type_name)(int, int)//like this，注意type_name的位置就行了 ​","categories":[],"tags":[]},{"title":"Project-run-008","slug":"Project-run-008","date":"2022-02-23T09:43:21.000Z","updated":"2022-03-15T21:01:54.593Z","comments":true,"path":"2022/02/23/Project-run-008/","link":"","permalink":"https://wthu1ew.github.io/2022/02/23/Project-run-008/","excerpt":"cpp学习，idapython学习，背单词","text":"cpp学习，idapython学习，背单词 前言：吐槽，学校外卖的沙拉都带着豆子，还是你妈妈的高碳水的那种豆子，所以我选择炸鸡，预计摄入70g碳水，今天总和好像超标了快35g了（哭） cpp学习：函数： 以后要改正自己的习惯，把函数原型写在main之前，而不是原型 + 定义一起写，这样编译的时候好像不会中断main，XD 只有在函数原型和函数头中 1arr[] 和 *arr 的含义才相同 可以记住这玩意： 12arr[i] = *(arr + i);&amp;arr[i] = arr + i; const和指针： (1). 让指针指向一个const，防止指针修改该常量 idapython学习：背单词：上午主要是复习寒假摸鱼的那段时间的单词： 估计晚上会制作30个单词对照的卡片（好费时间啊…）","categories":[],"tags":[]},{"title":"一些出pwn的思路记录","slug":"一些出pwn的思路记录","date":"2022-02-22T13:26:41.000Z","updated":"2022-02-22T13:53:40.361Z","comments":true,"path":"2022/02/22/一些出pwn的思路记录/","link":"","permalink":"https://wthu1ew.github.io/2022/02/22/%E4%B8%80%E4%BA%9B%E5%87%BApwn%E7%9A%84%E6%80%9D%E8%B7%AF%E8%AE%B0%E5%BD%95/","excerpt":"","text":"raw 结构体元素指定位数","categories":[],"tags":[]},{"title":"Project-run-007","slug":"Project-run-007","date":"2022-02-22T03:33:24.000Z","updated":"2022-03-15T21:01:03.810Z","comments":true,"path":"2022/02/22/Project-run-007/","link":"","permalink":"https://wthu1ew.github.io/2022/02/22/Project-run-007/","excerpt":"cpp学习，idapython学习","text":"cpp学习，idapython学习 前言：尝试做了个山寨币的小空 更新：草泥马，怎么开的是10x，-25%亏死我了呜呜呜 cpp虽然大一考了95，但是学的实在基础，于是乎重新学查漏补缺了。 cpp学习：一些杂碎： 数组初始化不允许宽窄转化 getline的换行符被替代为\\0（等等回来在内存看一下cin，cin.get） ​edit：好像大伙都一个b样 字符串相关： string可以直接赋值，拼接 用getline函数而不是cin.getline方法，istream类早于string类型 c++11的raw即表示自己（自动加转义字符了？），用法 R(“…”)，括号和引号之间可以加入其他符号作为分割标识符 ​ 结构相关： 结构中居然可以指定成员所占位数！惊了，like this： 123struct struct_name &#123; char test : 4;&#125; union和enum： union是一种数据格式，里面可以使用不同的数据类型，sizeof(union) &#x3D; sizeof(max(数据类型))，常用于系统数据结构，嵌入式这种内存紧张的东西里 enum创建了一种新的数据类型，{ }中的枚举量可以直接命名（不知道怎么表达），这样默认从0开始，依次++，但也可以赋值，感觉就像： 1234567891011enum enum_name &#123; A, B, C = 9&#125;;similar to# define A 0# define B 1# define C 9 只不过是被定义在了enum中，常用于定义一些符号常量 枚举量可以被提升为int，但int不可以变枚举量 枚举量存在取值范围，min &#x3D; 最大的小于min的2的幂 + 1，而max则是反过来，在这个范围里取值，即使枚举量未被定义，但依旧合法 基础io控制：照着书写了个最基础的输入输出的，但是fail那里检测不出类型不匹配啊，无论是数据类型还是文件类型… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;using namespace std;int main()&#123; string o_file_name; string i_file_name; cout &lt;&lt; &quot;enter name: &quot;; getline(cin, o_file_name); cin.clear(); cout.clear(); if (o_file_name.substr(o_file_name.size() - 4, o_file_name.size()) != &quot;.txt&quot;) &#123; o_file_name += &quot;.txt&quot;; &#125; ofstream o_file; ifstream i_file; int num = 0; double new_num = 0; cout &lt;&lt; &quot;enter num of number: &quot;; cin &gt;&gt; num; o_file.open(o_file_name); if (!o_file.is_open()) &#123; cout &lt;&lt; &quot;open error!\\n&quot;; exit(EXIT_FAILURE); &#125; cin &gt;&gt; fixed; cin.precision(2); cin.setf(ios_base::showpoint); for (int i = 0; i &lt; num; i++) &#123; cin &gt;&gt; new_num; o_file &lt;&lt; new_num; o_file &lt;&lt; &#x27; &#x27;; &#125; o_file.close(); i_file_name = o_file_name; i_file.open(i_file_name); if (!i_file.is_open()) &#123; cout &lt;&lt; &quot;open error!\\n&quot;; exit(EXIT_FAILURE); &#125; double value = 0; double sum = 0; i_file &gt;&gt; value; while (i_file.good()) &#123; sum += value; i_file &gt;&gt; value; &#125; if (i_file.eof()) &#123; cout &lt;&lt; &quot;this is end!\\n&quot;; &#125; else if (i_file.fail()) &#123; cout &lt;&lt; &quot;type not match!\\n&quot;; &#125; cout &lt;&lt; &quot;sum is: &quot; &lt;&lt; sum &lt;&lt; endl; i_file.close(); return 0;&#125; idapython学习：偷来的指令图： 对应的指令定义：来源 Analysisplan_and_wait(start, end)auto_mark_range(start, end, QType)delete_all_segments()demangle name(name, disableMask)Entry Pointsadd_entry(ord, ea, name, makecode)rename_entry(ord, name)get_entry_ordinal(index)get_entry(ord)get_entry_qty()Cross references (XRef)","categories":[],"tags":[]},{"title":"Project-run-006","slug":"Project-run-006","date":"2022-02-21T12:30:44.000Z","updated":"2022-03-15T21:00:21.964Z","comments":true,"path":"2022/02/21/Project-run-006/","link":"","permalink":"https://wthu1ew.github.io/2022/02/21/Project-run-006/","excerpt":"codeql深入学习","text":"codeql深入学习 前言：codeql cpp的snippets终于分析完了（真是懒狗，拖了那么久），以后简历可以改成熟悉codeql而不是了解啦！ codeql深入学习ternaryconditional：代码：12345import cpp from ConditionalExpr ce where ce.getThen().getType() != ce.getElse().getType()select ce 总结：判定 ：？的返回值类型是否一致 todocomment：代码：12345import cpp from Comment c where c.getContents().matches(&quot;%TODO%&quot;)select c 总结：查找指定注释（感觉效率不如ctrl+F…） toomanyparams：代码：12345import cpp from Function f where f.getNumberOfParameters() &gt;= 10 select f 总结：参数太他妈的多啦～ unusedlocalvar：代码：1234567import cpp from LocalScopeVariable lsv, LocalVariable lvwhere //not lsv instanceof Parameter //and not exists(lsv.getAnAccess()) not exists( lv.getAnAccess() )select lv 结果： 总结：寻找未被使用的变量，因为感觉loaclvariable写的简单点就用这个了。 LocalScopeVariable包含所有变量，包括函数参数。 StackScopeVariable不包含static和pthread，static基本是存在data或者bss段，pthread忘了。 LocalVariable不包含函数参数。 unusedmethod：代码：123456789import cpp from MemberFunction mf, FunctionCall fc where mf.getFile().getRelativePath() = &quot;a.cpp&quot; and fc.getTarget() = mf and not mf.isVirtual() and mf.isPrivate() select fc.getLocation().getStartLine() ,fc, mf 结果： 总结：其实思路还是很清晰的，但是自己做了很久，原因是我把使用函数的查询和使用变量的弄混了，都用了类似accesss的查询，但实际上函数得用call查询，而函数的access是查询的类似函数取地址的操作： 1&amp;functionname; unusedparam：代码：123456import cpp from Parameter p where not exists( p.getAnAccess() ) and p.isNamed()select p 总结：主要就那个isNamed要注意一下，但是这种不命名的参数用法我忘了叫啥了 voidreturntype：代码：123456import cpp from MemberFunction mf where mf.hasSpecifier(&quot;const&quot;) and mf.getType() instanceof VoidType select mf 结果： 总结：草，没见过的cpp用法增加了… volatilevariable：代码：12345import cppfrom Variable fwhere f.isVolatile()select f 总结：cpp没见过的用法喜加一","categories":[],"tags":[]},{"title":"Project-run-005","slug":"Project-run-005","date":"2022-02-14T09:16:50.000Z","updated":"2022-03-15T20:59:49.062Z","comments":true,"path":"2022/02/14/Project-run-005/","link":"","permalink":"https://wthu1ew.github.io/2022/02/14/Project-run-005/","excerpt":"codeql深入学习","text":"codeql深入学习 codeql深入学习：mutualrecursion:codeql代码：12345678910import cpp from Function m, Function n where exists( FunctionCall fc | fc.getTarget() = m and fc.getEnclosingFunction() = n ) and exists( FunctionCall fc | fc.getTarget() = n and fc.getEnclosingFunction() = m )select m, m.getLocation().getStartLine().toString(), n, n.getLocation().getStartLine().toString() 结果： 总结：查找互相调用的函数，靠functioncall处的enclosingfunction确定 override-method:代码：12345678910111213import cpp from MemberFunction override, MemberFunction base, File fwhere base.getDeclaringType().getABaseClass*().getName() = &quot;exception&quot; and base.getDeclaringType().getNamespace().toString().matches(&quot;%std%&quot;) and base.getName() = &quot;what&quot; and override.overrides*(base) and override.getFile() = f and f.getRelativePath().toString() = &quot;a.cpp&quot;select override.getDeclaringType(), override 结果： 总结：寻找被复写的成员函数，但是他给的用例我写的demo测试不出来（cpp菜逼是这样的），所以就改了个自己能测试出来的（逃 returnstatement:代码：123456import cpp from ReturnStmt rs where rs.getExpr().(Literal).getValue().toInt() = 0 and rs.getFile().getRelativePath() = &quot;a.cpp&quot;select rs 总结：寻找return 0，自己加了个文件路径指定而已 singletonblock:代码：1234import cpp from BlockStmt bs where bs.getNumStmt() = 1select bs 结果： 总结：注，getNumStmt() &#x3D; 1是针对 123&#123; &#125; 而不是 1&#123;&#125; 所以我推荐这里写getNumStmt()的值为0或1 switchcase:代码：123456import cpp from EnumSwitch es, EnumConstant ec where ec = es.getAMissingCase() and not es.hasDefaultCase() select es, ec 结果： 总结：获得没有default的枚举元素，但是本人很少写枚举+switch，所以个人还没什么理解","categories":[],"tags":[]},{"title":"Project-run-004","slug":"Project-run-004","date":"2022-02-12T18:00:16.000Z","updated":"2022-03-15T20:58:58.650Z","comments":true,"path":"2022/02/13/Project-run-004/","link":"","permalink":"https://wthu1ew.github.io/2022/02/13/Project-run-004/","excerpt":"cpp学习，codeql深入学习，简单算法，背单词","text":"cpp学习，codeql深入学习，简单算法，背单词 前言：今天必定完成全部学习任务，完不成后天不恰饭 cpp学习：map相关:属于map库，std:__1命名空间，建立映射可以使用make_pair codeql深入学习：Field-access:QL代码：1234567import cpp from Field f, FieldAccess fa where f.getName().matches(&quot;aDate&quot;) and f.getDeclaringType().getName() = &quot;Order&quot; and fa.getTarget() = f select fa 结果： 总结：嘛，查询了哪里对指定成员变量进行了操作，个人认为如果更实际一点就还需要补充些修改成员变量的函数调用处，懒得写了 Function-call:QL代码：12345678import cpp from Function f, FunctionCall fc where f.getDeclaringType().getSimpleName().matches(&quot;map&quot;) and f.getDeclaringType().getNamespace().toString().matches(&quot;%std%&quot;) and f.getName().matches(&quot;find&quot;) and fc.getTarget() = f select fc 结果： 总结：注：snnipets里写的function-call个人认为是错的，它对于namespace的处理有问题map属于namspace std::__1, 靠snnipets里的是无法搜索出结果的，所以得加个正则匹配才行 Integer-literal:QL代码：123456import cpp from Literal l where l.getType() instanceof IntType and l.getValue().toInt() = 2 select l.getLocation().getStartLine(), l 结果： 总结：单纯找一下哪里出现了值为2的整数int（我认为） 简单算法：贪心算法：无重叠区域：个人理解：其实一周前看过解析，今天自己做的时候只记得前区间的end要比后区间的begin小，但是忘了sort顺序，比较的是at(0)，导致一开始没做出来。 那么，正确的做法其实是比较at(1)，毕竟越早结束越可能产生更多区间，导致删除的区间更少。 coding:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int eraseOverlapIntervals(vector&lt; vector&lt;int&gt; &gt;&amp; intervals) &#123; int cnt=0; int current_second=0; sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123; return a[1]&lt;b[1]; &#125;); vector&lt; vector&lt;int&gt; &gt;::iterator it=intervals.begin(); current_second=it-&gt;at(1); it++; for(;it!=intervals.end();it++)&#123; if(it-&gt;at(0)&gt;=current_second)&#123; current_second=it-&gt;at(1); &#125;else&#123; cnt++; &#125; &#125; return cnt; &#125;&#125;;int main()&#123; int a[2]=&#123;3, 10&#125;; int b[2]=&#123;0, 5&#125;; int c[2]=&#123;4, 9&#125;; vector&lt;int&gt; aa(a, a+2); vector&lt;int&gt; bb(b, b+2); vector&lt;int&gt; cc(c, c+2); vector&lt; vector&lt;int&gt; &gt; vv; vv.push_back(aa); vv.push_back(bb); vv.push_back(cc); Solution *s=new Solution; cout&lt;&lt;s-&gt;eraseOverlapIntervals(vv); return 0;&#125; 用最少数量飞镖引爆气球: 个人理解：ok，我宣布喜欢让迭代器从end开始操作的人都是大傻逼，这很容易导致越界访问内存～ 言归正传，有点像上一题，不过一开始自己思路错了，想成了考虑最大集合了，应该还是归到集合边界问题。 coding：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int findMinArrowShots(vector&lt; vector&lt;int&gt; &gt;&amp; points) &#123; int start_position = 0; int arrows_num = 0; sort(points.begin(), points.end(), [](vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b)&#123; return a[1] &lt; b[1]; &#125;); vector&lt; vector&lt;int&gt; &gt;::iterator it = points.begin(); start_position = it-&gt;at(1); arrows_num++, it++; for(; it!=points.end(); it++)&#123; if(start_position &gt;= it-&gt;at(0))&#123; continue; &#125;else&#123; arrows_num++; start_position = it-&gt;at(1); &#125; &#125; return arrows_num; &#125;&#125;;int main() &#123; vector&lt;int&gt; a = &#123;1, 2&#125;; vector&lt;int&gt; b = &#123;2, 3&#125;; vector&lt;int&gt; c = &#123;3, 4&#125;; vector&lt;int&gt; d = &#123;4, 5&#125;; vector&lt; vector&lt;int&gt; &gt; v; v.push_back(a); v.push_back(b); v.push_back(c); v.push_back(d); Solution *s = new Solution; cout &lt;&lt; s-&gt;findMinArrowShots(v) &lt;&lt;endl; return 0;&#125; 背单词：复习了30个例句","categories":[],"tags":[{"name":"Project-run","slug":"Project-run","permalink":"https://wthu1ew.github.io/tags/Project-run/"}]},{"title":"Project-run-003","slug":"Project-run-003","date":"2022-02-09T10:55:53.000Z","updated":"2022-02-12T18:03:14.653Z","comments":true,"path":"2022/02/09/Project-run-003/","link":"","permalink":"https://wthu1ew.github.io/2022/02/09/Project-run-003/","excerpt":"修改博客，codeql深入学习","text":"修改博客，codeql深入学习 前言：前两天和Sakura聊了一下，他说codeql不是一个特别完善的工具，最好的用处是不用数据流也能找到的漏洞模式，就好像 1234567a函数里调用b函数对a函数的字段进行初始化但是b函数有一个if判断可以在对指针初始化前就返回造成未初始化的引用Codeql可以很轻松的找到函数a调用函数b，以及函数b里有一个return这种情况 （Sakura原话） So，最近打算看完cpp snippets就OK啦！ 博客修改：照着链接整了一下Google的seo，方便以后搜索到自己以及站内搜索 codeql深入学习:Castexpr:强制类型转换，自己魔改了一下，从非浮点数转化为浮点数（本来好像是浮点数变非浮点数） QL代码：123456789101112131415/** 自己写的不是那么正确的demo qlimport cpp from Cast cwhere c.getType() instanceof FloatingPointType and c.getExpr().getType() instanceof IntTypeselect c*/import cppfrom Cast cwhere c.getType() instanceof FloatingPointType and c.getExpr().getType() instanceof IntegralTypeselect c 结果： 总结：1234getExpr() //获得右式instanceof ... //判定是否为...的子类FloatingPointType //浮点类型，不是float类型指针哈哈哈IntegralType //除了enum和浮点数，都可以是这个子类 Constructor-call:寻找调用构造函数 QL代码：123456import cpp from NewExpr new, Constructor cwhere c = new.getInitializer().(ConstructorCall).getTarget() and c.hasName(&quot;Mynew&quot;) select new 结果： 总结：先通过右式的new加上寻找构造的约束，之后强制类型转换为ConstructorCall（FunctionCall的派生）获取目标，最后通过名字寻找 Derives-from-class：寻找派生类 QL代码：123456import cpp from Class c where c.getABaseClass+().getName().matches(&quot;exception&quot;) and c.getNamespace().getName().matches(&quot;std&quot;) select c 结果： 总结：通过迭代获得最顶层基类的名字且进行约束，由于exception本身就是std命名空间的，所以只要对子类进行命名空间的约束即可 Emptyblock:总结：通过count对getAStmt()进行了计数的一个简单封装，不高兴写demo了 Emptythen:QL代码：12345import cpp from IfStmt is where is.getThen().(BlockStmt).getNumStmt()=0 select is 总结：看一下留个印象就行，不难 困惑： 注释里的4.1.1啥的，到底是指的啥，懵逼 Catch-exception的内容看不懂，就先放着了","categories":[],"tags":[{"name":"Project-run","slug":"Project-run","permalink":"https://wthu1ew.github.io/tags/Project-run/"}]},{"title":"Project_run_002","slug":"Project-run-002","date":"2022-02-05T04:56:04.000Z","updated":"2022-02-12T18:03:22.411Z","comments":true,"path":"2022/02/05/Project-run-002/","link":"","permalink":"https://wthu1ew.github.io/2022/02/05/Project-run-002/","excerpt":"博客修改，cql深入学习，简单算法","text":"博客修改，cql深入学习，简单算法 博客修改：最终还是选择对封面图使用了远程链接，修改了_config.yml后使用标签语法 1&#123;% asset_img img_path ... %&#125; 发现对于封面的cover：，在执行 1hexo g 的时候就会报错了（麻） 简单算法：75. 颜色分类：一开始想用的单指针，分别对0与1处理，总共处理两次，但想想觉得好麻烦，就看到题解里的神解法了，算是动态规划？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt; #include &lt;vector&gt;using namespace std;class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int i=0, len=nums.size(); int zero=0,one=0,two=0; for(;i&lt;len;i++)&#123; if(nums.at(i)==2)&#123; nums.at(two++)=2; &#125; else if(nums.at(i)==1)&#123; nums.at(two++)=2; nums.at(one++)=1; &#125; else if(nums.at(i)==0)&#123; nums.at(two++)=2; nums.at(one++)=1; nums.at(zero++)=0; &#125; /* for(int i=0;i&lt;nums.size();i++)&#123; cout&lt;&lt;nums.at(i)&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl; */ &#125; &#125;&#125;;int main()&#123; int ori[6]=&#123;1,2,0,2,0,1&#125;; vector&lt;int&gt; nums(ori, ori+6); Solution s; s.sortColors(nums); for(int i=0;i&lt;nums.size();i++)&#123; cout&lt;&lt;nums.at(i)&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl; return 0;&#125; 455. 分发饼干：自己随便写了个，然后润到B站再看看贪心算法（原来这玩意不是具体算法，而是局部最佳试图整体最佳的想法2333） 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt; using namespace std; class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; sort(g.begin(), g.end()); sort(s.begin(), s.end()); int cnt=0; for(int i=0;i&lt;s.size();i++)&#123; if(s.at(i)&gt;=g.at(0))&#123; for(;(i+cnt)&lt;s.size()&amp;&amp;cnt&lt;g.size();cnt++)&#123; if(s.at(i+cnt)&lt;g.at(cnt))&#123; break; &#125; &#125; &#125; &#125; return cnt; &#125;&#125;;int main()&#123; Solution S; int a[10]=&#123;1,3,2,5,4,6,7,8,7,9&#125;; int b[5]=&#123;1,0,9,7,4&#125;; vector&lt;int&gt; g(a,a+10); vector&lt;int&gt; s(b,b+5); cout&lt;&lt;S.findContentChildren(g,s)&lt;&lt;endl; return 0;&#125; cql深入学习：今天直接尝试阅读了源码，对于getchild（）存在一些疑惑，明天问完skr再回来补补 源码+注释没好意思问，就自己实践了一下，直接贴源码+自己的注释了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class ArrayExpr extends Expr, @subscriptexpr &#123; override string getAPrimaryQlClass() &#123; result = &quot;ArrayExpr&quot; &#125; /** * 获得被指向的数组或者指针 * This is `arr` in both `arr[0]` and `0[arr]`. */ Expr getArrayBase() &#123; result = this.getChild(0) &#125; /** * 获得数组索引的表达式 * This is `0` in both `arr[0]` and `0[arr]`. */ Expr getArrayOffset() &#123; result = this.getChild(1) &#125; /** * 赋值，自增/减，函数调用则视为被改变 * Holds if this array access is in a position where it is (directly) modified, * for instance by an assignment or an increment/decrement operation. */ predicate isModified() &#123; exists(Assignment a | a.getLValue() = this) or exists(CrementOperation c | c.getOperand() = this) or exists(FunctionCall c | c.getQualifier() = this and c.getTarget().hasName(&quot;operator=&quot;)) &#125; override string toString() &#123; result = &quot;access to array&quot; &#125; /** * 可能被污染？数组本身，偏移被污染，若不确定则也被认为被污染 */ override predicate mayBeImpure() &#123; this.getArrayBase().mayBeImpure() or this.getArrayOffset().mayBeImpure() or this.getArrayBase().getFullyConverted().getType().(DerivedType).getBaseType().isVolatile() or this.getArrayOffset().getFullyConverted().getType().(DerivedType).getBaseType().isVolatile() &#125; /** * 搜索全局污染，不确定也被认为是污染，但它只针对全局变量 * 局部变量再怎么被污染也不被考虑 */ override predicate mayBeGloballyImpure() &#123; this.getArrayBase().mayBeGloballyImpure() or this.getArrayOffset().mayBeGloballyImpure() or this.getArrayBase().getFullyConverted().getType().(DerivedType).getBaseType().isVolatile() or this.getArrayOffset().getFullyConverted().getType().(DerivedType).getBaseType().isVolatile() &#125;&#125;","categories":[],"tags":[{"name":"Project-run","slug":"Project-run","permalink":"https://wthu1ew.github.io/tags/Project-run/"}]},{"title":"Project_run_001","slug":"Project-run-001","date":"2022-02-04T12:03:05.000Z","updated":"2022-02-12T18:03:01.389Z","comments":true,"path":"2022/02/04/Project-run-001/","link":"","permalink":"https://wthu1ew.github.io/2022/02/04/Project-run-001/","excerpt":"今日学习博客搭建，cql深入","text":"今日学习博客搭建，cql深入 博客搭建：主要记录一点自己踩的坑： 使用的nexmoe主题，它的背景是默认磨花的，想不磨花则进入 1/themes/nexmoe/source/css/style.styl 修改blur（）函数的参数为0px 关于图片的链接，可以为远程链接和本地链接（？） 远程链接：点击服务器上的图片，然后复制图片链接即可 本地链接：分为相对路径和绝对路径，我暂时采用的相对路径，设置 1/scaffolds/post.md 添加 1typora-root-url: ../ 使得typora的默认路径修改为和hexo一样的 1/source 而不是 1/source/_post nexmoe中默认带有广告，我选择把_config.nexmoe.yml中最后的sidebar全注释掉了，去你吗的备案号啥的XD 在设置好_config.yml中的themes之后，基本要修改设置就只在 1/_config.nexmoe.yml 中修改就行了，不要弄 1/themes/nexmoe/_config.yml 改了也不会体现在博客上的 cql环节：预计会先把cql自带的demo和曾经的cwe给研究完再研究更深入的，例子都是官网下载的内容中自带的，我就直接用名字，不提供ql代码了，除非自己魔改过 addressof:demo.c:1234567891011121314void test(int* b, int&amp; c);int main()&#123; int a=0; int* b=&amp;a; int&amp; c=a; test(b, c); return 0;&#125;void test(int* b, int&amp; c)&#123; b=&amp;c; return;&#125; 结果:","categories":[],"tags":[{"name":"Project-run","slug":"Project-run","permalink":"https://wthu1ew.github.io/tags/Project-run/"}]},{"title":"杂谈","slug":"杂谈","date":"2022-02-01T18:18:37.627Z","updated":"2022-02-05T21:04:25.670Z","comments":true,"path":"2022/02/02/杂谈/","link":"","permalink":"https://wthu1ew.github.io/2022/02/02/%E6%9D%82%E8%B0%88/","excerpt":"","text":"本人纯懒狗pwn手，博客建设中 个人成分很杂，鉴定为引流蛆","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"pwn college","slug":"pwn-college","permalink":"https://wthu1ew.github.io/tags/pwn-college/"},{"name":"Project-run","slug":"Project-run","permalink":"https://wthu1ew.github.io/tags/Project-run/"}]}